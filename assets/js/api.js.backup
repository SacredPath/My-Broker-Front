/**
 * API Client - Single entry point for all network calls
 * Uses singleton Supabase client, fetchEdge with timeouts, AbortController, and standardized error mapping
 * Keep-alive ping every 10 minutes
 */

class APIClient {
  constructor() {
    this.supabaseClient = null;
    this.keepAliveInterval = null;
    this.requestQueue = new Map();
    this.init();
  }

  init() {
    this.initSupabase();
    // this.startKeepAlive(); // Temporarily disabled due to auth issues
  }

  initSupabase() {
    try {
      // Use singleton SupabaseClient from supabaseClient.js
      if (window.SupabaseClient && window.SupabaseClient.getClient) {
        this.supabase = window.SupabaseClient.supabase;
        console.debug('[APIClient] Using singleton SupabaseClient');
        return;
      }
      
      throw new Error('SupabaseClient singleton not found');
    } catch (error) {
      console.error('[APIClient] Failed to get Supabase client:', error);
      
      // Show user-friendly error if notify exists
      if (window.Notify) {
        window.Notify.error('Failed to connect to the service. Please refresh the page.');
      } else {
        console.error('[APIClient] Supabase initialization failed:', error.message);
      }
      
      throw error;
    }
  }

  // Fetch with timeout and abort controller
  async fetchWithTimeout(url, options = {}, { timeoutMs = 10000, retry = 1 } = {}) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

    const fetchOptions = {
      ...options,
      signal: controller.signal
    };

    let lastError;
    let attempt = 0;

    while (attempt <= retry) {
      try {
        const response = await fetch(url, fetchOptions);
        clearTimeout(timeoutId);
        return response;
      } catch (error) {
        lastError = error;
        clearTimeout(timeoutId);

        // Don't retry on abort or client errors
        if (error.name === 'AbortError' || 
            (error.status >= 400 && error.status < 500)) {
          break;
        }

        attempt++;
        if (attempt <= retry) {
          console.log(`Retrying once after error: ${error.message}`);
          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }

    throw lastError;
  }

  // Central error mapper
  mapError(err, responseJson = null, status = null) {
    // Single console log per error
    const requestId = responseJson?.requestId || status || 'unknown';
    console.error(`API Error [${requestId}]:`, {
      message: err.message,
      status,
      kind: err.name
    });

    // Network/timeout errors
    if (err.name === 'AbortError' || err.message.includes('timeout')) {
      return {
        kind: 'network',
        title: 'Connection Error',
        message: 'Please check your internet connection and try again.'
      };
    }

    // HTTP status based mapping
    if (status === 401 || responseJson?.error === 'UNAUTHENTICATED') {
      return {
        kind: 'auth',
        title: 'Authentication Required',
        message: 'Please sign in again to continue.'
      };
    }

    if (status === 403 || responseJson?.error === 'FORBIDDEN') {
      return {
        kind: 'permission',
        title: 'Access Denied',
        message: 'You don\'t have permission to perform this action.'
      };
    }

    if (status === 422 || responseJson?.error?.includes('VALIDATION')) {
      return {
        kind: 'validation',
        title: 'Invalid Input',
        message: responseJson?.detail || 'Please check your input and try again.'
      };
    }

    if (status >= 500) {
      return {
        kind: 'server_error',
        title: 'Server Error',
        message: 'Something went wrong on our end. Please try again later.'
      };
    }

    // Default/unknown errors
    return {
      kind: 'unknown',
      title: 'Error',
      message: responseJson?.detail || err.message || 'An unexpected error occurred.'
    };
  }

  // Edge Functions caller with timeout and abort
  async fetchEdge(functionName, options = {}) {
    const {
      method = 'GET',
      body,
      timeout = 10000,
      retries = 1, // Reduced to 1 retry max
      requireAuth = true
    } = options;

    // Build the URL
    const url = `${this.supabase.supabaseUrl}/functions/v1/${functionName}`;
    
    // Only get session token if auth is required
    let token = null;
    if (requireAuth) {
      const { data: { session } } = await this.supabase.auth.getSession();
      token = session?.access_token || null;
      
      if (!token) {
        const error = new Error('Authentication required');
        error.code = 'AUTH_REQUIRED';
        throw error;
      }
    }

    // Build fetch options with proper headers
    const headers = {
      'apikey': window.__ENV?.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVieWNvZXl1dGF1empneGJvemNtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk0MDYyOTIsImV4cCI6MjA4NDk4MjI5Mn0.NUqdlArOGnCUEXuQYummEgsJKHoTk3fUvBarKIagHMM'
    };
    
    // Add Content-Type only for POST/PUT
    if (method === 'POST' || method === 'PUT') {
      headers['Content-Type'] = 'application/json';
    }
    
    // Add Authorization header with user token if auth required
    if (requireAuth && token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    // Prepare request config
    const config = {
      method,
      headers,
    };

    if (body) {
      config.body = JSON.stringify(body);
    }

    // Make the request with timeout and retry
    try {
      const response = await this.fetchWithTimeout(url, config, { 
        timeoutMs: timeout, 
        retry: retries 
      });
      
      const status = response.status;
      const text = await response.text();
      
      // Parse body as JSON if possible
      let body = null;
      try {
        body = JSON.parse(text);
      } catch {
        body = { raw: text };
      }
      
      // If not OK, throw error with mapped details
      if (!response.ok) {
        const error = new Error(body.error || body.message || `HTTP ${status}`);
        error.status = status;
        error.body = body;
        throw error;
      }
      
      // Return body for successful responses
      return body;
    } catch (error) {
      // Map error and throw with additional context
      const mappedError = this.mapError(error, error.body, error.status);
      error.mappedError = mappedError;
      throw error;
    }
  }

  standardizeError(error) {
    const standardizedError = new Error();

    if (error.name === 'AbortError') {
      standardizedError.message = 'Request timed out. Please try again.';
      standardizedError.code = 'TIMEOUT';
      standardizedError.userMessage = 'Request timed out';
    } else if (error.message.includes('Failed to fetch')) {
      standardizedError.message = 'Network connection failed. Check your internet connection.';
      standardizedError.code = 'NETWORK_ERROR';
      standardizedError.userMessage = 'Connection failed';
    } else if (error.message.includes('Authentication required')) {
      standardizedError.message = 'Please sign in to continue.';
      standardizedError.code = 'AUTH_REQUIRED';
      standardizedError.userMessage = 'Sign in required';
    } else if (error.message.includes('HTTP 401')) {
      standardizedError.message = 'Your session has expired. Please sign in again.';
      standardizedError.code = 'SESSION_EXPIRED';
      standardizedError.userMessage = 'Session expired';
    } else if (error.message.includes('HTTP 403')) {
      standardizedError.message = 'Access denied. You do not have permission to perform this action.';
      standardizedError.code = 'FORBIDDEN';
      standardizedError.userMessage = 'Access denied';
    } else if (error.message.includes('HTTP 500')) {
      // Include detail from server error if available
      let detailMessage = 'Server error occurred. Please try again later.';
      if (error.detail) {
        detailMessage = `Server error: ${error.detail}`;
      }
      standardizedError.message = detailMessage;
      standardizedError.code = 'SERVER_ERROR';
      standardizedError.userMessage = 'Server error';
    } else if (error.jsonBody) {
      // Handle JSON error responses with error/detail
      const { error: errorCode, detail } = error.jsonBody;
      let message = errorCode || 'Unknown error';
      if (detail) {
        message += `: ${detail}`;
      }
      standardizedError.message = message;
      standardizedError.code = errorCode || 'UNKNOWN_ERROR';
      standardizedError.detail = detail;
      standardizedError.userMessage = message;
    } else {
      standardizedError.message = error.message || 'An unexpected error occurred. Please try again.';
      standardizedError.code = 'UNKNOWN_ERROR';
      standardizedError.userMessage = 'Something went wrong';
    }

    standardizedError.originalError = error;
    return standardizedError;
  }

  // Keep-alive ping every 10 minutes
  startKeepAlive() {
    // Clear existing interval
    if (this.keepAliveInterval) {
      clearInterval(this.keepAliveInterval);
    }

    // Set up new interval (10 minutes = 600000ms)
    this.keepAliveInterval = setInterval(async () => {
      try {
        await this.fetchEdge('keepalive', {
          method: 'POST',
          timeout: 5000,
          retries: 0,
          requireAuth: false,
          background: true
        });
        if (window.__ENV?.DEBUG_EDGE === '1') {
          console.debug('[APIClient] Keep-alive ping successful');
        }
      } catch (error) {
        // Fail silently for background tasks
        if (window.__ENV?.DEBUG_EDGE === '1') {
          console.debug('[APIClient] Keep-alive ping failed:', error.message);
        }
        // Stop scheduling further pings if the first ping fails due to network issues
        if (this.keepAliveInterval) {
          clearInterval(this.keepAliveInterval);
          this.keepAliveInterval = null;
          if (window.__ENV?.DEBUG_EDGE === '1') {
            console.debug('[APIClient] Stopping keepalive due to persistent failures');
          }
        }
      }
    }, 600000); // 10 minutes

    // Initial ping
    this.pingKeepAlive();
  }

  async pingKeepAlive() {
    try {
      await this.fetchEdge('keepalive', {
        method: 'POST',
        timeout: 5000,
        retries: 0,
        requireAuth: false,
        background: true
      });
      if (window.__ENV?.DEBUG_EDGE === '1') {
        console.debug('[APIClient] Initial keep-alive ping successful');
      }
    } catch (error) {
      // Fail silently for background tasks
      if (window.__ENV?.DEBUG_EDGE === '1') {
        console.debug('[APIClient] Initial keep-alive ping failed:', error.message);
      }
      // If initial ping fails, stop the keepalive interval to prevent repeated failures
      if (this.keepAliveInterval) {
        clearInterval(this.keepAliveInterval);
        this.keepAliveInterval = null;
        if (window.__ENV?.DEBUG_EDGE === '1') {
          console.debug('[APIClient] Stopping keepalive due to initial failure');
        }
      }
    }
  }

  stopKeepAlive() {
    if (this.keepAliveInterval) {
      clearInterval(this.keepAliveInterval);
      this.keepAliveInterval = null;
    }
  }

  // Authentication methods
  async signUp(email, password, options = {}) {
    try {
      const { data, error } = await this.supabase.auth.signUp({
        email,
        password,
        options
      });

      if (error) throw error;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  async signIn(email, password) {
    try {
      const { data, error } = await this.supabase.auth.signInWithPassword({
        email,
        password
      });

      if (error) throw error;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  async signInWithGoogle() {
    try {
      const { data, error } = await this.supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: `${window.location.origin}/auth/callback`
        }
      });

      if (error) throw error;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  async signOut() {
    try {
      const { error } = await this.supabase.auth.signOut();
      if (error) throw error;
      return { data: null, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  async getCurrentUser() {
    try {
      const { data: { user }, error } = await this.supabase.auth.getUser();
      if (error) throw error;
      return { data: user, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  async getSession() {
    try {
      const { data: { session }, error } = await this.supabase.auth.getSession();
      if (error) throw error;
      return { data: session, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  // Database methods (wrapper for Supabase client)
  async from(table) {
    return this.supabase.from(table);
  }

  async rpc(functionName, params = {}) {
    try {
      const { data, error } = await this.supabase.rpc(functionName, params);
      if (error) throw error;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  // Storage methods
  async upload(bucket, path, file, options = {}) {
    try {
      const { data, error } = await this.supabase.storage
        .from(bucket)
        .upload(path, file, options);
      
      if (error) throw error;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  async getPublicUrl(bucket, path) {
    try {
      const { data } = this.supabase.storage
        .from(bucket)
        .getPublicUrl(path);
      
      return { data: data.publicUrl, error: null };
    } catch (error) {
      return { data: null, error: this.standardizeError(error) };
    }
  }

  // Utility method to check if user is authenticated
  isAuthenticated() {
    return this.supabase.auth.getUser().then(({ data: { user } }) => !!user);
  }

  // Get exchange rate (handles provider not configured)
  async getExchangeRate() {
    return this.fetchEdge('/fx-rate', {
      method: 'GET',
      requireAuth: false,
      timeout: 5000,
      retries: 0 // No retries for provider errors
    });
  }

  // Create payment intent (handles provider not configured)
  async createPaymentIntent(amount, currency = 'usd') {
    return this.fetchEdge('/stripe-payment', {
      method: 'POST',
      body: { amount, currency },
      requireAuth: true,
      timeout: 10000,
      retries: 0 // No retries for provider errors
    });
  }

  // Verify all Edge Functions are working
  async verifyEdgeFunctions() {
    console.log('üîç Starting Edge Function verification...');
    
    // First check auth_debug
    console.log('\n--- AUTH DEBUG CHECK ---');
    let authResult = null;
    try {
      authResult = await this.fetchEdge('auth_debug', { 
        method: 'GET', 
        timeout: 8000, 
        retries: 0,
        requireAuth: true
      });
      
      console.log('Auth Debug Result:', authResult);
      
      // Stop if auth fails
      if (!authResult.ok || authResult.userId === null) {
        console.error('\n‚ùå AUTH DEBUG FAILED - STOPPING VERIFICATION');
        console.error('Auth debug response:', JSON.stringify(authResult, null, 2));
        
        // Show modal to user
        if (window.showModal) {
          window.showModal({
            title: 'Auth Debug Failed',
            message: 'Token not being sent or rejected. Check console for details.',
            primaryText: 'OK'
          });
        }
        
        return [{
          fn: 'auth_debug',
          method: 'GET',
          status: 'error',
          okField: false,
          errorField: 'Authentication failed',
          requestId: authResult.requestId,
          ms: 0,
          sentAuth: false,
          sentApiKey: false,
          sentAuthPrefix: null
        }];
      }
      
      console.log('‚úÖ Auth debug passed - user ID:', authResult.userId);
      
    } catch (error) {
      console.error('\n‚ùå AUTH DEBUG EXCEPTION - STOPPING VERIFICATION');
      console.error('Auth debug error:', error);
      
      if (window.showModal) {
        window.showModal({
          title: 'Auth Debug Failed',
          message: 'Token not being sent or rejected. Check console for details.',
          primaryText: 'OK'
        });
      }
      
      return [{
        fn: 'auth_debug',
        method: 'GET',
        status: 'error',
        okField: false,
        errorField: error.message,
        requestId: null,
        ms: 0,
        sentAuth: false,
        sentApiKey: false,
        sentAuthPrefix: null
      }];
    }
    
    // If auth passed, continue with other functions
    const functions = [
      'rbac_me',
      'tiers_list',
      'user_balances',
      'keepalive',
      'positions_list',
      'dashboard_summary',
      'portfolio_snapshot',
      'history_feed',
      'withdrawal_settings',
      'conversion_history',
      'user_withdrawal_methods',
      'signals_list',
      'signal_access_check',
      'audit_list',
      'deposit_settings',
      'deposit_create_order',
      'convert_usdt_to_usd',
      'withdraw_create_request'
    ];
    
    const results = [];
    
    for (const fn of functions) {
      // Get session info for logging
      const { data: { session } } = await this.supabase.auth.getSession();
      const token = session?.access_token;
      const sentAuth = !!token;
      const sentApiKey = !!window.__ENV?.SUPABASE_ANON_KEY;
      const sentAuthPrefix = token ? token.substring(0, 12) : null;
      
      // Test GET
      const getStart = Date.now();
      let getStatus = 'error';
      let getError = null;
      let getDuration = 0;
      let requestId = null;
      
      try {
        const result = await this.fetchEdge(fn, { 
          method: 'GET', 
          timeout: 8000, 
          retries: 1,
          requireAuth: fn !== 'keepalive' // keepalive is public
        });
        
        getDuration = Date.now() - getStart;
        getStatus = 'success';
        requestId = result.requestId || null;
        
        // Parse JSON and check ok field
        const okField = result?.ok === true;
        const errorField = result?.error || null;
        
        // For keepalive, any response is ok
        const finalOk = fn === 'keepalive' ? true : okField;
        
        results.push({
          fn,
          method: 'GET',
          status: getStatus,
          okField: finalOk,
          errorField,
          requestId,
          ms: getDuration,
          sentAuth,
          sentApiKey,
          sentAuthPrefix
        });
        
      } catch (e) {
        getDuration = Date.now() - getStart;
        getStatus = 'error';
        getError = e.body?.error || e.message;
        requestId = e.body?.requestId || null;
        
        results.push({
          fn,
          method: 'GET',
          status: getStatus,
          okField: false,
          errorField: getError,
          requestId,
          ms: getDuration,
          sentAuth,
          sentApiKey,
          sentAuthPrefix
        });
      }
      
      console.log(`${finalOk ? '‚úÖ' : '‚ùå'} ${fn} - GET: ${getStatus} (${getDuration}ms)`);
    }
    
    // Summary table with exact columns requested
    console.log('\nüìä VERIFICATION SUMMARY:');
    console.table(results.map(r => ({
      fn: r.fn,
      method: r.method,
      status: r.status,
      okField: r.okField,
      errorField: r.errorField,
      requestId: r.requestId,
      ms: r.ms,
      sentAuth: r.sentAuth,
      sentApiKey: r.sentApiKey,
      sentAuthPrefix: r.sentAuthPrefix
    })));
    
    const successCount = results.filter(r => r.okField).length;
    const totalCount = results.length;
    
    console.log(`\nüéØ RESULT: ${successCount}/${totalCount} functions working`);
    
    if (successCount === totalCount) {
      console.log('üéâ ALL FUNCTIONS OPERATIONAL');
    } else {
      console.log('‚ö†Ô∏è  Some functions have issues - check details above');
    }
    
    return results;
  }

  // Cleanup method
  destroy() {
    this.stopKeepAlive();
  }
}

// Initialize global API client
window.API = new APIClient();

// Expose verification harness
window.EdgeVerify = {
  run: () => window.API.verifyEdgeFunctions(),
  
  // Helper to check if user is authenticated
  checkAuth: async () => {
    if (!window.SupabaseClient) {
      console.log('‚ùå SupabaseClient not found');
      return false;
    }
    if (!window.SupabaseClient.supabase) {
      console.log('‚ùå Supabase client not initialized');
      return false;
    }
    
    try {
      const session = await window.SupabaseClient.supabase.auth.getSession();
      if (!session || !session.data.session || !session.data.session.access_token) {
        console.log('‚ùå Not authenticated - please log in first');
        return false;
      }
      console.log('‚úÖ Authentication OK');
      return true;
    } catch (e) {
      console.log('‚ùå Failed to check authentication:', e.message);
      return false;
    }
  }
};

class APIClient {
  // ... (rest of the class remains the same)

  // Centralized balance data transformer
  transformBalanceData(balances) {
    if (!balances) {
      return {
        USD: { available: 0, locked: 0 },
        USDT: { available: 0, locked: 0 },
        total: 0,
        usd: 0,
        usdt: 0
      };
    }

    // Standardize to nested structure
    const standardized = {
      USD: {
        available: balances.USD?.available || balances.usd || 0,
        locked: balances.USD?.locked || 0
      },
      USDT: {
        available: balances.USDT?.available || balances.usdt || 0,
        locked: balances.USDT?.locked || 0
      }
    };

    // Add computed flat properties for compatibility
    standardized.total = standardized.USD.available + standardized.USDT.available;
    standardized.usd = standardized.USD.available;
    standardized.usdt = standardized.USDT.available;

    return standardized;
  }

  // Standardized balance fetch method
  async fetchBalances() {
    try {
      const { data, error } = await this.fetchEdge('user_balances', {
        method: 'GET'
      });

      if (error) {
        throw error;
      }

      return this.transformBalanceData(data.balances);
    } catch (error) {
      console.error('Failed to fetch balances:', error);
      return this.transformBalanceData(null);
    }
  }
};

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
  module.exports = APIClient;
}
